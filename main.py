#!/usr/bin/env python3
"""
Point d'entr√©e principal pour l'assistant Minion Masters.
Ce module orchestre tous les composants : d√©tection, strat√©gie, et overlay.
"""

import sys
import time
import signal
import argparse
import threading
from typing import Optional

import config
from detector import create_detector, MinionDetector
from strategy import create_strategy_analyzer, StrategyAnalyzer
from overlay import create_overlay_controller, OverlayController
from utils import format_time_duration


class MinionMastersAssistant:
    """
    Classe principale qui coordonne tous les composants de l'assistant.
    G√®re la d√©tection, l'analyse strat√©gique et l'affichage des suggestions.
    """
    
    def __init__(self, debug_mode: bool = False, stats_interval: float = 5.0):
        """
        Initialise l'assistant complet.
        
        Args:
            debug_mode: Active l'affichage des √©l√©ments de debug
            stats_interval: Intervalle d'affichage des statistiques (secondes)
        """
        self.debug_mode = debug_mode
        self.stats_interval = stats_interval
        
        # Composants principaux
        self.detector: Optional[MinionDetector] = None
        self.strategy_analyzer: Optional[StrategyAnalyzer] = None
        self.overlay_controller: Optional[OverlayController] = None
        
        # √âtat de l'application
        self.is_running = False
        self.start_time = 0
        self.frame_count = 0
        self.last_stats_time = 0
        
        # Thread principal d'analyse
        self.analysis_thread: Optional[threading.Thread] = None
        self.stop_event = threading.Event()
        
        print(\"üöÄ Assistant Minion Masters initialis√©\")
        print(f\"   Mode debug: {'ACTIV√â' if debug_mode else 'D√âSACTIV√â'}\")
        print(f\"   Joueur plac√© √†: {config.PLAYER_SIDE.upper()}\")
    
    def initialize_components(self):
        \"\"\"Initialise tous les composants de l'assistant.\"\"\"\n        try:\n            # 1. D√©tecteur OpenCV\n            print(\"üîç Initialisation du d√©tecteur...\")\n            self.detector = create_detector()\n            \n            # 2. Analyseur strat√©gique\n            print(\"üß† Initialisation de l'analyseur strat√©gique...\")\n            self.strategy_analyzer = create_strategy_analyzer(\n                config.MONITOR[\"width\"], \n                config.MONITOR[\"height\"]\n            )\n            \n            # 3. Overlay graphique\n            print(\"üé® Initialisation de l'overlay...\")\n            self.overlay_controller = create_overlay_controller()\n            \n            print(\"‚úÖ Tous les composants initialis√©s avec succ√®s\")\n            return True\n            \n        except Exception as e:\n            print(f\"‚ùå Erreur lors de l'initialisation: {e}\")\n            return False\n    \n    def start(self):\n        \"\"\"D√©marre l'assistant complet.\"\"\"\n        if self.is_running:\n            print(\"‚ö†Ô∏è  L'assistant est d√©j√† en cours d'ex√©cution\")\n            return False\n        \n        # Initialiser les composants\n        if not self.initialize_components():\n            return False\n        \n        # D√©marrer l'overlay\n        print(\"üñºÔ∏è  D√©marrage de l'overlay...\")\n        self.overlay_controller.start(close_callback=self._on_overlay_closed)\n        \n        # Attendre que l'overlay soit pr√™t\n        timeout = 10.0\n        start_wait = time.time()\n        while not self.overlay_controller.is_active() and (time.time() - start_wait) < timeout:\n            time.sleep(0.1)\n        \n        if not self.overlay_controller.is_active():\n            print(\"‚ùå Impossible de d√©marrer l'overlay\")\n            return False\n        \n        # Configuration du mode debug\n        if self.debug_mode:\n            self.overlay_controller.toggle_debug()\n        \n        # D√©marrage de l'analyse\n        print(\"üî¨ D√©marrage de l'analyse...\")\n        self.is_running = True\n        self.start_time = time.time()\n        self.last_stats_time = self.start_time\n        \n        # Thread d'analyse principal\n        self.analysis_thread = threading.Thread(\n            target=self._analysis_loop,\n            daemon=True,\n            name=\"AnalysisThread\"\n        )\n        self.analysis_thread.start()\n        \n        # Affichage des informations de d√©marrage\n        self._print_startup_info()\n        \n        return True\n    \n    def _analysis_loop(self):\n        \"\"\"Boucle principale d'analyse et de traitement.\"\"\"\n        try:\n            while self.is_running and not self.stop_event.is_set():\n                loop_start = time.time()\n                \n                # 1. Traitement d'une frame\n                active_minions, enemy_minions = self.detector.process_frame()\n                self.frame_count += 1\n                \n                # 2. Analyse strat√©gique\n                suggestion_position = None\n                \n                if enemy_minions:\n                    # Placement standard bas√© sur les menaces actuelles\n                    suggestion_position = self.strategy_analyzer.calculate_optimal_placement(enemy_minions)\n                    \n                    # Optionnel : placement pr√©dictif pour les situations complexes\n                    if len(enemy_minions) >= 3:  # Situations avec beaucoup d'ennemis\n                        predictive_position = self.strategy_analyzer.get_predictive_placement(enemy_minions)\n                        if predictive_position:\n                            suggestion_position = predictive_position\n                \n                else:\n                    # Aucun ennemi d√©tect√© - position par d√©faut ou None\n                    suggestion_position = None\n                \n                # 3. Mise √† jour de l'overlay\n                self.overlay_controller.update_suggestion(suggestion_position)\n                \n                # 4. Mise √† jour des marqueurs de debug\n                if self.debug_mode:\n                    self._update_debug_markers(active_minions, enemy_minions)\n                \n                # 5. Affichage p√©riodique des statistiques\n                current_time = time.time()\n                if current_time - self.last_stats_time >= self.stats_interval:\n                    self._print_statistics(active_minions, enemy_minions)\n                    self.last_stats_time = current_time\n                \n                # 6. Contr√¥le du framerate\n                loop_duration = time.time() - loop_start\n                sleep_time = max(0, config.FRAME_DELAY - loop_duration)\n                if sleep_time > 0:\n                    time.sleep(sleep_time)\n                \n        except KeyboardInterrupt:\n            print(\"\\n‚èπÔ∏è  Interruption clavier d√©tect√©e\")\n            self.stop()\n        except Exception as e:\n            print(f\"‚ùå Erreur dans la boucle d'analyse: {e}\")\n            self.stop()\n    \n    def _update_debug_markers(self, active_minions, enemy_minions):\n        \"\"\"Met √† jour les marqueurs de debug sur l'overlay.\"\"\"\n        # Effacer les anciens marqueurs\n        self.overlay_controller.clear_minion_markers()\n        \n        # Ajouter les marqueurs pour les minions actifs\n        for minion in active_minions:\n            if minion.positions:\n                position = minion.positions[-1]\n                is_enemy = minion in enemy_minions\n                \n                self.overlay_controller.add_minion_marker(\n                    minion.id, position, is_enemy=is_enemy\n                )\n                \n                # Ajouter les positions pr√©dites si disponibles\n                if minion.predicted_positions:\n                    for pred_pos in minion.predicted_positions[-3:]:  # 3 derni√®res pr√©dictions\n                        self.overlay_controller.add_minion_marker(\n                            f\"{minion.id}_pred\", (pred_pos[0], pred_pos[1]), \n                            is_enemy=False, is_predicted=True\n                        )\n    \n    def _print_statistics(self, active_minions, enemy_minions):\n        \"\"\"Affiche les statistiques de performance et de d√©tection.\"\"\"\n        current_time = time.time()\n        uptime = current_time - self.start_time\n        fps = self.frame_count / uptime if uptime > 0 else 0\n        \n        # Statistiques de d√©tection\n        detection_stats = self.detector.get_detection_stats()\n        \n        # Statistiques de strat√©gie\n        strategy_stats = self.strategy_analyzer.get_strategy_stats()\n        \n        print(f\"\\nüìä STATISTIQUES - {format_time_duration(uptime)}\")\n        print(f\"   üñºÔ∏è  FPS moyen: {fps:.1f} | Frames trait√©es: {self.frame_count}\")\n        print(f\"   üîç Minions d√©tect√©s: {detection_stats['total_minions']} (actifs: {detection_stats['active_minions']})\")\n        print(f\"   ‚öîÔ∏è  Ennemis identifi√©s: {detection_stats['enemy_minions']}\")\n        print(f\"   üß† Placements effectu√©s: {strategy_stats['total_placements']}\")\n        \n        if strategy_stats['current_strategy']:\n            print(f\"   üéØ Strat√©gie actuelle: {strategy_stats['current_strategy']} (√ó{strategy_stats['consecutive_same']})\")\n        \n        # Affichage d√©taill√© en mode debug\n        if self.debug_mode:\n            print(f\"   üîß Distribution r√©cente: {strategy_stats.get('recent_strategy_distribution', {})}\")\n    \n    def _print_startup_info(self):\n        \"\"\"Affiche les informations de d√©marrage.\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"üéÆ ASSISTANT MINION MASTERS - D√âMARR√â\")\n        print(\"=\"*60)\n        print(f\"üì∫ R√©solution: {config.MONITOR['width']}x{config.MONITOR['height']}\")\n        print(f\"üë§ Joueur: C√¥t√© {config.PLAYER_SIDE.upper()}\")\n        print(f\"üõ°Ô∏è  Seuil d√©fensif: {config.SAFE_ZONE_THRESHOLD} ennemis proches\")\n        print(f\"üîÆ Pr√©diction: {config.PREDICTION_TIME}s √† l'avance\")\n        print(\"\\nüéØ L'assistant analyse maintenant vos parties !\")\n        print(\"   ‚Ä¢ Cercle VERT = Suggestion de placement optimal\")\n        if self.debug_mode:\n            print(\"   ‚Ä¢ Points BLEUS = Positions d√©fensives\")\n            print(\"   ‚Ä¢ Points ROUGES = Positions offensives\")\n            print(\"   ‚Ä¢ Points VERTS = Positions centrales\")\n            print(\"   ‚Ä¢ Marqueurs CYAN = Minions alli√©s\")\n            print(\"   ‚Ä¢ Marqueurs ROUGES = Minions ennemis\")\n            print(\"   ‚Ä¢ Marqueurs JAUNES = Positions pr√©dites\")\n        print(\"\\n‚å®Ô∏è  CONTR√îLES:\")\n        print(\"   ‚Ä¢ CTRL+C = Arr√™ter l'assistant\")\n        print(\"   ‚Ä¢ Fermer l'overlay = Arr√™ter l'assistant\")\n        print(\"=\"*60 + \"\\n\")\n    \n    def _on_overlay_closed(self):\n        \"\"\"Callback appel√© quand l'overlay est ferm√©.\"\"\"\n        print(\"üî¥ Overlay ferm√© par l'utilisateur\")\n        self.stop()\n    \n    def stop(self):\n        \"\"\"Arr√™te l'assistant et nettoie les ressources.\"\"\"\n        if not self.is_running:\n            return\n        \n        print(\"\\n‚èπÔ∏è  Arr√™t de l'assistant...\")\n        self.is_running = False\n        self.stop_event.set()\n        \n        # Arr√™t de l'overlay\n        if self.overlay_controller:\n            self.overlay_controller.stop()\n        \n        # Attendre la fin du thread d'analyse\n        if self.analysis_thread and self.analysis_thread.is_alive():\n            self.analysis_thread.join(timeout=3.0)\n        \n        # Nettoyage du d√©tecteur\n        if self.detector:\n            self.detector.cleanup()\n        \n        # Statistiques finales\n        if self.start_time > 0:\n            uptime = time.time() - self.start_time\n            avg_fps = self.frame_count / uptime if uptime > 0 else 0\n            print(f\"\\nüìä SESSION TERMIN√âE\")\n            print(f\"   ‚è±Ô∏è  Dur√©e: {format_time_duration(uptime)}\")\n            print(f\"   üñºÔ∏è  Frames trait√©es: {self.frame_count}\")\n            print(f\"   üìà FPS moyen: {avg_fps:.1f}\")\n        \n        print(\"\\n‚úÖ Assistant arr√™t√©. Au revoir !\")\n    \n    def toggle_debug_mode(self):\n        \"\"\"Active/d√©sactive le mode debug.\"\"\"\n        self.debug_mode = not self.debug_mode\n        if self.overlay_controller:\n            self.overlay_controller.toggle_debug()\n        print(f\"üîß Mode debug: {'ACTIV√â' if self.debug_mode else 'D√âSACTIV√â'}\")\n\n\ndef signal_handler(signum, frame):\n    \"\"\"Gestionnaire de signaux pour un arr√™t propre.\"\"\"\n    print(f\"\\nüî¥ Signal {signum} re√ßu - Arr√™t en cours...\")\n    if hasattr(signal_handler, 'assistant') and signal_handler.assistant:\n        signal_handler.assistant.stop()\n    sys.exit(0)\n\n\ndef parse_arguments():\n    \"\"\"Parse les arguments de ligne de commande.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Assistant d'analyse automatique pour Minion Masters\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExemples d'utilisation:\n  python main.py                    # D√©marrage normal\n  python main.py --debug            # Avec affichage debug\n  python main.py --stats 10         # Statistiques toutes les 10s\n  python main.py --player right     # Joueur plac√© √† droite\n\nConfiguration:\n  Modifiez config.py pour ajuster les param√®tres de d√©tection,\n  les positions strat√©giques et les seuils de l'assistant.\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        \"--debug\", \"-d\", \n        action=\"store_true\", \n        help=\"Active le mode debug avec visualisations suppl√©mentaires\"\n    )\n    \n    parser.add_argument(\n        \"--stats\", \"-s\",\n        type=float,\n        default=5.0,\n        help=\"Intervalle d'affichage des statistiques en secondes (d√©faut: 5.0)\"\n    )\n    \n    parser.add_argument(\n        \"--player\", \"-p\",\n        choices=[\"left\", \"right\"],\n        help=\"Force le c√¥t√© du joueur (remplace config.PLAYER_SIDE)\"\n    )\n    \n    parser.add_argument(\n        \"--no-overlay\", \n        action=\"store_true\",\n        help=\"Mode console uniquement (sans overlay graphique)\"\n    )\n    \n    return parser.parse_args()\n\n\ndef main():\n    \"\"\"Point d'entr√©e principal de l'application.\"\"\"\n    try:\n        # Parse des arguments\n        args = parse_arguments()\n        \n        # Configuration optionnelle du c√¥t√© joueur\n        if args.player:\n            config.PLAYER_SIDE = args.player\n            print(f\"üîÑ C√¥t√© joueur configur√©: {args.player.upper()}\")\n        \n        # Mode sans overlay (pour tests ou debugging)\n        if args.no_overlay:\n            print(\"‚ö†Ô∏è  Mode console uniquement - overlay d√©sactiv√©\")\n            # TODO: Impl√©menter un mode console pur\n            print(\"‚ùå Mode non-overlay pas encore impl√©ment√©\")\n            return 1\n        \n        # V√©rification des pr√©requis\n        try:\n            import cv2\n            import mss\n            import tkinter as tk\n        except ImportError as e:\n            print(f\"‚ùå D√©pendance manquante: {e}\")\n            print(\"üí° Installez avec: pip install opencv-python mss\")\n            return 1\n        \n        # Configuration des gestionnaires de signaux\n        signal.signal(signal.SIGINT, signal_handler)\n        signal.signal(signal.SIGTERM, signal_handler)\n        \n        # Cr√©ation et d√©marrage de l'assistant\n        assistant = MinionMastersAssistant(\n            debug_mode=args.debug,\n            stats_interval=args.stats\n        )\n        \n        # R√©f√©rence pour le gestionnaire de signaux\n        signal_handler.assistant = assistant\n        \n        # D√©marrage\n        if not assistant.start():\n            print(\"‚ùå Impossible de d√©marrer l'assistant\")\n            return 1\n        \n        # Attendre la fin de l'ex√©cution\n        try:\n            while assistant.is_running:\n                time.sleep(0.5)\n        except KeyboardInterrupt:\n            pass\n        \n        # Arr√™t propre\n        assistant.stop()\n        return 0\n        \n    except Exception as e:\n        print(f\"‚ùå Erreur fatale: {e}\")\n        import traceback\n        traceback.print_exc()\n        return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n