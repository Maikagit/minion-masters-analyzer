#!/usr/bin/env python3
"""
Point d'entrée principal pour l'assistant Minion Masters.
Ce module orchestre tous les composants : détection, stratégie, et overlay.
"""

import sys
import time
import signal
import argparse
import threading
from typing import Optional

import config
from detector import create_detector, MinionDetector
from strategy import create_strategy_analyzer, StrategyAnalyzer
from overlay import create_overlay_controller, OverlayController
from utils import format_time_duration


class MinionMastersAssistant:
    """
    Classe principale qui coordonne tous les composants de l'assistant.
    Gère la détection, l'analyse stratégique et l'affichage des suggestions.
    """
    
    def __init__(self, debug_mode: bool = False, stats_interval: float = 5.0):
        """
        Initialise l'assistant complet.
        
        Args:
            debug_mode: Active l'affichage des éléments de debug
            stats_interval: Intervalle d'affichage des statistiques (secondes)
        """
        self.debug_mode = debug_mode
        self.stats_interval = stats_interval
        
        # Composants principaux
        self.detector: Optional[MinionDetector] = None
        self.strategy_analyzer: Optional[StrategyAnalyzer] = None
        self.overlay_controller: Optional[OverlayController] = None
        
        # État de l'application
        self.is_running = False
        self.start_time = 0
        self.frame_count = 0
        self.last_stats_time = 0
        
        # Thread principal d'analyse
        self.analysis_thread: Optional[threading.Thread] = None
        self.stop_event = threading.Event()
        
        print(\"🚀 Assistant Minion Masters initialisé\")
        print(f\"   Mode debug: {'ACTIVÉ' if debug_mode else 'DÉSACTIVÉ'}\")
        print(f\"   Joueur placé à: {config.PLAYER_SIDE.upper()}\")
    
    def initialize_components(self):
        \"\"\"Initialise tous les composants de l'assistant.\"\"\"\n        try:\n            # 1. Détecteur OpenCV\n            print(\"🔍 Initialisation du détecteur...\")\n            self.detector = create_detector()\n            \n            # 2. Analyseur stratégique\n            print(\"🧠 Initialisation de l'analyseur stratégique...\")\n            self.strategy_analyzer = create_strategy_analyzer(\n                config.MONITOR[\"width\"], \n                config.MONITOR[\"height\"]\n            )\n            \n            # 3. Overlay graphique\n            print(\"🎨 Initialisation de l'overlay...\")\n            self.overlay_controller = create_overlay_controller()\n            \n            print(\"✅ Tous les composants initialisés avec succès\")\n            return True\n            \n        except Exception as e:\n            print(f\"❌ Erreur lors de l'initialisation: {e}\")\n            return False\n    \n    def start(self):\n        \"\"\"Démarre l'assistant complet.\"\"\"\n        if self.is_running:\n            print(\"⚠️  L'assistant est déjà en cours d'exécution\")\n            return False\n        \n        # Initialiser les composants\n        if not self.initialize_components():\n            return False\n        \n        # Démarrer l'overlay\n        print(\"🖼️  Démarrage de l'overlay...\")\n        self.overlay_controller.start(close_callback=self._on_overlay_closed)\n        \n        # Attendre que l'overlay soit prêt\n        timeout = 10.0\n        start_wait = time.time()\n        while not self.overlay_controller.is_active() and (time.time() - start_wait) < timeout:\n            time.sleep(0.1)\n        \n        if not self.overlay_controller.is_active():\n            print(\"❌ Impossible de démarrer l'overlay\")\n            return False\n        \n        # Configuration du mode debug\n        if self.debug_mode:\n            self.overlay_controller.toggle_debug()\n        \n        # Démarrage de l'analyse\n        print(\"🔬 Démarrage de l'analyse...\")\n        self.is_running = True\n        self.start_time = time.time()\n        self.last_stats_time = self.start_time\n        \n        # Thread d'analyse principal\n        self.analysis_thread = threading.Thread(\n            target=self._analysis_loop,\n            daemon=True,\n            name=\"AnalysisThread\"\n        )\n        self.analysis_thread.start()\n        \n        # Affichage des informations de démarrage\n        self._print_startup_info()\n        \n        return True\n    \n    def _analysis_loop(self):\n        \"\"\"Boucle principale d'analyse et de traitement.\"\"\"\n        try:\n            while self.is_running and not self.stop_event.is_set():\n                loop_start = time.time()\n                \n                # 1. Traitement d'une frame\n                active_minions, enemy_minions = self.detector.process_frame()\n                self.frame_count += 1\n                \n                # 2. Analyse stratégique\n                suggestion_position = None\n                \n                if enemy_minions:\n                    # Placement standard basé sur les menaces actuelles\n                    suggestion_position = self.strategy_analyzer.calculate_optimal_placement(enemy_minions)\n                    \n                    # Optionnel : placement prédictif pour les situations complexes\n                    if len(enemy_minions) >= 3:  # Situations avec beaucoup d'ennemis\n                        predictive_position = self.strategy_analyzer.get_predictive_placement(enemy_minions)\n                        if predictive_position:\n                            suggestion_position = predictive_position\n                \n                else:\n                    # Aucun ennemi détecté - position par défaut ou None\n                    suggestion_position = None\n                \n                # 3. Mise à jour de l'overlay\n                self.overlay_controller.update_suggestion(suggestion_position)\n                \n                # 4. Mise à jour des marqueurs de debug\n                if self.debug_mode:\n                    self._update_debug_markers(active_minions, enemy_minions)\n                \n                # 5. Affichage périodique des statistiques\n                current_time = time.time()\n                if current_time - self.last_stats_time >= self.stats_interval:\n                    self._print_statistics(active_minions, enemy_minions)\n                    self.last_stats_time = current_time\n                \n                # 6. Contrôle du framerate\n                loop_duration = time.time() - loop_start\n                sleep_time = max(0, config.FRAME_DELAY - loop_duration)\n                if sleep_time > 0:\n                    time.sleep(sleep_time)\n                \n        except KeyboardInterrupt:\n            print(\"\\n⏹️  Interruption clavier détectée\")\n            self.stop()\n        except Exception as e:\n            print(f\"❌ Erreur dans la boucle d'analyse: {e}\")\n            self.stop()\n    \n    def _update_debug_markers(self, active_minions, enemy_minions):\n        \"\"\"Met à jour les marqueurs de debug sur l'overlay.\"\"\"\n        # Effacer les anciens marqueurs\n        self.overlay_controller.clear_minion_markers()\n        \n        # Ajouter les marqueurs pour les minions actifs\n        for minion in active_minions:\n            if minion.positions:\n                position = minion.positions[-1]\n                is_enemy = minion in enemy_minions\n                \n                self.overlay_controller.add_minion_marker(\n                    minion.id, position, is_enemy=is_enemy\n                )\n                \n                # Ajouter les positions prédites si disponibles\n                if minion.predicted_positions:\n                    for pred_pos in minion.predicted_positions[-3:]:  # 3 dernières prédictions\n                        self.overlay_controller.add_minion_marker(\n                            f\"{minion.id}_pred\", (pred_pos[0], pred_pos[1]), \n                            is_enemy=False, is_predicted=True\n                        )\n    \n    def _print_statistics(self, active_minions, enemy_minions):\n        \"\"\"Affiche les statistiques de performance et de détection.\"\"\"\n        current_time = time.time()\n        uptime = current_time - self.start_time\n        fps = self.frame_count / uptime if uptime > 0 else 0\n        \n        # Statistiques de détection\n        detection_stats = self.detector.get_detection_stats()\n        \n        # Statistiques de stratégie\n        strategy_stats = self.strategy_analyzer.get_strategy_stats()\n        \n        print(f\"\\n📊 STATISTIQUES - {format_time_duration(uptime)}\")\n        print(f\"   🖼️  FPS moyen: {fps:.1f} | Frames traitées: {self.frame_count}\")\n        print(f\"   🔍 Minions détectés: {detection_stats['total_minions']} (actifs: {detection_stats['active_minions']})\")\n        print(f\"   ⚔️  Ennemis identifiés: {detection_stats['enemy_minions']}\")\n        print(f\"   🧠 Placements effectués: {strategy_stats['total_placements']}\")\n        \n        if strategy_stats['current_strategy']:\n            print(f\"   🎯 Stratégie actuelle: {strategy_stats['current_strategy']} (×{strategy_stats['consecutive_same']})\")\n        \n        # Affichage détaillé en mode debug\n        if self.debug_mode:\n            print(f\"   🔧 Distribution récente: {strategy_stats.get('recent_strategy_distribution', {})}\")\n    \n    def _print_startup_info(self):\n        \"\"\"Affiche les informations de démarrage.\"\"\"\n        print(\"\\n\" + \"=\"*60)\n        print(\"🎮 ASSISTANT MINION MASTERS - DÉMARRÉ\")\n        print(\"=\"*60)\n        print(f\"📺 Résolution: {config.MONITOR['width']}x{config.MONITOR['height']}\")\n        print(f\"👤 Joueur: Côté {config.PLAYER_SIDE.upper()}\")\n        print(f\"🛡️  Seuil défensif: {config.SAFE_ZONE_THRESHOLD} ennemis proches\")\n        print(f\"🔮 Prédiction: {config.PREDICTION_TIME}s à l'avance\")\n        print(\"\\n🎯 L'assistant analyse maintenant vos parties !\")\n        print(\"   • Cercle VERT = Suggestion de placement optimal\")\n        if self.debug_mode:\n            print(\"   • Points BLEUS = Positions défensives\")\n            print(\"   • Points ROUGES = Positions offensives\")\n            print(\"   • Points VERTS = Positions centrales\")\n            print(\"   • Marqueurs CYAN = Minions alliés\")\n            print(\"   • Marqueurs ROUGES = Minions ennemis\")\n            print(\"   • Marqueurs JAUNES = Positions prédites\")\n        print(\"\\n⌨️  CONTRÔLES:\")\n        print(\"   • CTRL+C = Arrêter l'assistant\")\n        print(\"   • Fermer l'overlay = Arrêter l'assistant\")\n        print(\"=\"*60 + \"\\n\")\n    \n    def _on_overlay_closed(self):\n        \"\"\"Callback appelé quand l'overlay est fermé.\"\"\"\n        print(\"🔴 Overlay fermé par l'utilisateur\")\n        self.stop()\n    \n    def stop(self):\n        \"\"\"Arrête l'assistant et nettoie les ressources.\"\"\"\n        if not self.is_running:\n            return\n        \n        print(\"\\n⏹️  Arrêt de l'assistant...\")\n        self.is_running = False\n        self.stop_event.set()\n        \n        # Arrêt de l'overlay\n        if self.overlay_controller:\n            self.overlay_controller.stop()\n        \n        # Attendre la fin du thread d'analyse\n        if self.analysis_thread and self.analysis_thread.is_alive():\n            self.analysis_thread.join(timeout=3.0)\n        \n        # Nettoyage du détecteur\n        if self.detector:\n            self.detector.cleanup()\n        \n        # Statistiques finales\n        if self.start_time > 0:\n            uptime = time.time() - self.start_time\n            avg_fps = self.frame_count / uptime if uptime > 0 else 0\n            print(f\"\\n📊 SESSION TERMINÉE\")\n            print(f\"   ⏱️  Durée: {format_time_duration(uptime)}\")\n            print(f\"   🖼️  Frames traitées: {self.frame_count}\")\n            print(f\"   📈 FPS moyen: {avg_fps:.1f}\")\n        \n        print(\"\\n✅ Assistant arrêté. Au revoir !\")\n    \n    def toggle_debug_mode(self):\n        \"\"\"Active/désactive le mode debug.\"\"\"\n        self.debug_mode = not self.debug_mode\n        if self.overlay_controller:\n            self.overlay_controller.toggle_debug()\n        print(f\"🔧 Mode debug: {'ACTIVÉ' if self.debug_mode else 'DÉSACTIVÉ'}\")\n\n\ndef signal_handler(signum, frame):\n    \"\"\"Gestionnaire de signaux pour un arrêt propre.\"\"\"\n    print(f\"\\n🔴 Signal {signum} reçu - Arrêt en cours...\")\n    if hasattr(signal_handler, 'assistant') and signal_handler.assistant:\n        signal_handler.assistant.stop()\n    sys.exit(0)\n\n\ndef parse_arguments():\n    \"\"\"Parse les arguments de ligne de commande.\"\"\"\n    parser = argparse.ArgumentParser(\n        description=\"Assistant d'analyse automatique pour Minion Masters\",\n        formatter_class=argparse.RawDescriptionHelpFormatter,\n        epilog=\"\"\"\nExemples d'utilisation:\n  python main.py                    # Démarrage normal\n  python main.py --debug            # Avec affichage debug\n  python main.py --stats 10         # Statistiques toutes les 10s\n  python main.py --player right     # Joueur placé à droite\n\nConfiguration:\n  Modifiez config.py pour ajuster les paramètres de détection,\n  les positions stratégiques et les seuils de l'assistant.\n        \"\"\"\n    )\n    \n    parser.add_argument(\n        \"--debug\", \"-d\", \n        action=\"store_true\", \n        help=\"Active le mode debug avec visualisations supplémentaires\"\n    )\n    \n    parser.add_argument(\n        \"--stats\", \"-s\",\n        type=float,\n        default=5.0,\n        help=\"Intervalle d'affichage des statistiques en secondes (défaut: 5.0)\"\n    )\n    \n    parser.add_argument(\n        \"--player\", \"-p\",\n        choices=[\"left\", \"right\"],\n        help=\"Force le côté du joueur (remplace config.PLAYER_SIDE)\"\n    )\n    \n    parser.add_argument(\n        \"--no-overlay\", \n        action=\"store_true\",\n        help=\"Mode console uniquement (sans overlay graphique)\"\n    )\n    \n    return parser.parse_args()\n\n\ndef main():\n    \"\"\"Point d'entrée principal de l'application.\"\"\"\n    try:\n        # Parse des arguments\n        args = parse_arguments()\n        \n        # Configuration optionnelle du côté joueur\n        if args.player:\n            config.PLAYER_SIDE = args.player\n            print(f\"🔄 Côté joueur configuré: {args.player.upper()}\")\n        \n        # Mode sans overlay (pour tests ou debugging)\n        if args.no_overlay:\n            print(\"⚠️  Mode console uniquement - overlay désactivé\")\n            # TODO: Implémenter un mode console pur\n            print(\"❌ Mode non-overlay pas encore implémenté\")\n            return 1\n        \n        # Vérification des prérequis\n        try:\n            import cv2\n            import mss\n            import tkinter as tk\n        except ImportError as e:\n            print(f\"❌ Dépendance manquante: {e}\")\n            print(\"💡 Installez avec: pip install opencv-python mss\")\n            return 1\n        \n        # Configuration des gestionnaires de signaux\n        signal.signal(signal.SIGINT, signal_handler)\n        signal.signal(signal.SIGTERM, signal_handler)\n        \n        # Création et démarrage de l'assistant\n        assistant = MinionMastersAssistant(\n            debug_mode=args.debug,\n            stats_interval=args.stats\n        )\n        \n        # Référence pour le gestionnaire de signaux\n        signal_handler.assistant = assistant\n        \n        # Démarrage\n        if not assistant.start():\n            print(\"❌ Impossible de démarrer l'assistant\")\n            return 1\n        \n        # Attendre la fin de l'exécution\n        try:\n            while assistant.is_running:\n                time.sleep(0.5)\n        except KeyboardInterrupt:\n            pass\n        \n        # Arrêt propre\n        assistant.stop()\n        return 0\n        \n    except Exception as e:\n        print(f\"❌ Erreur fatale: {e}\")\n        import traceback\n        traceback.print_exc()\n        return 1\n\n\nif __name__ == \"__main__\":\n    sys.exit(main())\n